\documentclass[12pt]{article}

\title{Insert Report Title Here}
\author{Benjamin White-Horne \\ \emph{Oxford University}}

\newcommand{\row}[1]{\texttt{#1}}

\begin{document}

\maketitle

\pagebreak

\section*{Abstract (W.I.P.)}

Change ringing is an artform which is almost exclusive to England, where people ring sets of bells
in continually evolving sequences, known as ``changes'' or ``rows''.  

More specifically, this project is concerned with the art of `composing' --- designing sequences of
rows for ringers to perform.  The art of composing predates computers by several centuries, so
composers have historically created compositions using pen, paper and copious amounts of both skill and
patience.  However, change ringing compositions are at their core sequences of permutations and are
therefore extremely ameanable to both mathematical and computer analysis.  Even the
first computers have been used to mechanise parts of composing (namely ``proving'' --- verifying
that a composition contains no repeated rows), and as the increasing speed of computers has been
exploited to allow computers to fully generate some compositions.

But brute force is still no match for the creativity of human composers, and one mostly unexplored area
of composing is software that \emph{aids} human composers by giving instant feedback and
visualisations to a composer whilst not requiring them to make drastic changes to their workflow.
This is analogous to what software like Musescore or Sibelius do for composing music.

\pagebreak

\tableofcontents

\pagebreak

\section{Introduction}

\subsection{Problems that this project is trying to solve}

(This bit is notes that I will write up later)

\begin{itemize}
    \item Suppose that I am composing a composition
    \item Composers don't always compose from start to finish \\
        $\Rightarrow$ a helpful composing program does not rely on entering a composition from
        start to finish
    \item I want to know if my composition is false as soon as possible whilst composing (I don't
        care if my comp doesn't start and end in rounds, I just want to build up any set of fragments
        of composition and I want to know if their combination is true or if not, exactly how they
        are false).
    \item I may want to check other properties about my composition whilst composing:
        \begin{itemize}
            \item Row search (How many 4-bell runs does my composition have;
                How many rows match \row{xxxx5678};
                Does my composition so far contain a specific row, e.g. Queens/\row{13572468})
        \end{itemize}
\end{itemize}

\subsection{An example composition workflow}

Here's an example of a potential composition workflow.  For the example, I'm going to be trying to
make a one-part peal of Ytterbium Surprise
Major\footnote{Blueline: https://rsw.me.uk/blueline/methods/view/Ytterbium\_Surprise\_Major}, with
a focus on music content over simplicity.

\subsubsection{Specifying a composition}

Any composition is primarily restricted by two factors:

\begin{enumerate}
    \item The number of rows that our composition is allowed to take up.  In this example, we are
        composing a peal, which has to include at least 5000 rows.  However, we want to `overrun'
        this value of 5000 by as few rows as possible because the more rows a composition has the
        longer it will take to ring.  In practice, values between 5000 and 5200 are almost ubiquitous,
        with the vast majority being between 5000 and 5100.
    \item The specific falseness of the method(s) used.  This arises from the fact that, when designing
        a composition, we add rows in atomic chunks (in 99\% of cases, these chunks are one lead of
        a single method).  Therefore, whilst composing, we could wind up in a situation where some
        rows are completely impossible to reach since every chunk that contains that row also
        contains at least one row already in the composition.  For some methods this restriction is
        worse than others --- I've chosen Ytterbium because its falseness is very predictable and
        easy to work with.
\end{enumerate}

\noindent Because of these restrictions, we are extremely likely to reach a situation where we have
to decide which rows to use and which to throw away.  So before starting to fill rows, we need to
specify what we want to include in our composition.  For the sake of this example, I will be using
the following:

\begin{enumerate}
    \item We want to include all 24 possible rows of each of the types \row{xxxx5678}, \row{xxxx8765},
        \row{xxxx6578}, \row{5678xxxx}, \row{8765xxxx}.
    \item We want to include the row known as ``Queens'' (\row{13572468}), and along the way we might
        ring other rows of the form \row{xxxx2468} which are also nice to have.
    \item We want as many runs of at least 4 bells as possible off either end of the change
        (the longer the better).  For example \row{345678xx} is preferrable to \row{xxxx4321}.
\end{enumerate}

\subsubsection{Starting the composition}

The first thing I want to do as a composer is to figure out how to get all 120 of the rows specified
in \#1 above before starting on the rest of the composition.  This is the first place that a computer
can help us (but currently can't), since we need to check that so far our plan (a) is true, and (b)
actually contains the 120 rows we want it to contain.

For example, all compositions must start and end in rounds (\row{12345678}), and if we were to
continue ringing from rounds without placing calls, we would ring a sequence of rows known as the
``plain course'' of Ytterbium.  An inspection of the plain course shows us that it contains the
following rows that we need: 6$\times$\row{xxxx5678}, 5$\times$\row{8765xxxx},
2$\times$\row{xxxx6578}.  It therefore makes sense that rotating 234 will give us more courses
containing more these desirable rows.

Experience and experimentation tells me that in order to get all 24$\times$ \row{xxxx5678},
24$\times$\row{8765xxxx} and 24$\times$\row{xxxx6578} from Ytterbium, we need to ring every lead of
the courses starting with the rows that correspond to the permutations of the form
${[(234)(56)]}^n \; \forall n \in \{0..5\}$.  To get the remaining rows, we need to ring the
courses starting with \row{1(234|342|423)8765} and \row{1(234|342|423)7865}.  This gives us 12
courses, totalling 2688 rows containing the 120 that we want.

These courses are non-negotiable --- they must exist in the final composition in order for it to
meet the above specification.  Therefore, we may only add new sections to the composition if they
are not false against these existing sections.

It's also worth noting that these 12 courses can be rung in 4 continous blocks of 3 courses (each
block stitched together by 3 bobs affecting just 234).  We do, however, still have to stitch these
blocks into one contiguous composition in such a way that the remainder is as musical as possible.

\subsubsection{Adding Queens}

--- snip ---



\pagebreak

\section{An initial design}

\subsection{Requirements}

To give a way of ranking the result of this project, I will give a set of requirements for the
application that I will develop.  I think that the resulting application should:

\begin{enumerate}
    \item Be a cross-platform GUI-based application that is easy to install and run, and should
        leverage the visual aspect of GUIs to aid the composer.  The program should feel snappy and
        responsive, even on lower end machines.
    \item Be general enough to represent anything in change ringing.
    \item Be able to handle `partial' compositions --- i.e.\ a composition does not have to be a
        round block starting and ending in rounds.  Ideally, a composition should be an unordered
        set of `fragments', each of which is a block (not necessarily round) that starts at a given
        row.
    \item Represent falseness in a way that's easily digestible to composers, in a way that shows
        the composer exactly \emph{which} rows are false, not just where the falseness is.
    \item Provide a customisable music scoring system, to allow the composer to specify exactly what
        they care about in this composition.
    \item Provide easy support for multi-part compositions, used for both proving and music scoring.
\end{enumerate}

To achieve goal \textbf{(1)} in a reasonable amount of time, I'm going to start by writing the GUI
as a web page (likely much of the graphics code will be JavaScript) with the `backend' code written
in Rust and compiled to WebAssembly.

\bigskip

\noindent In an attempt to satisfy the remaining goals, I propose the following design.

\subsection{The design}

\subsubsection{Goal \#3: Partial Compositions}

I propose that we store an unfinished/`partial' composition as a set of unordered and independent
pieces which are generated and proved as a whole.  I'll call these pieces `fragments' and they can
be thought of as miniature compositions in their own right, inasmuch as they should are intended to
be rung as a section but don't necessarily start or end at rounds.  This program will model the
composing process as repeatedly manipulating fragments until a true round block is reached which has
the desired properties (length, music content, etc.).

Ways of modifying fragments should include:

\begin{itemize}
    \item \textbf{Deleting} an existing fragment
    \item \textbf{Creating} a new fragment from a block and a starting row
    \item \textbf{Splitting} a fragment at some position to produce two fragments
    \item \textbf{Reversing} a fragment so all its rows occur in the opposite order
    \item \textbf{Extending} a fragment (either at the start or end) to make that fragment longer
    \item \textbf{Combining} two fragments (if the first row of the second is the `leftover' row
        from the first).
    \item Perhaps also \textbf{inserting} round blocks into existing fragments
\end{itemize}

\subsubsection{Goal \#6: Multipart Compositions}

In order to elegantly handle multipart comps, we allow the user to specify an arbitrary set $P$ of
rows as part heads.  Then, each row that the user sees is `expanded' into multiple separate rows by
premultiplying with each of the specified part heads.  Therefore, when the user adds a row $r$ to
the composition, they are in fact adding $|P|$ rows ($pr \, \forall \, p \in P$), and the proving
and music scoring will work over this expanded set of rows.

\end{document}
