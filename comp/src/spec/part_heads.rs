//! Code for part head specification.

use std::{cell::RefCell, collections::HashSet};

use bellframe::{IncompatibleStages, InvalidRowError, Row, RowBuf, Stage};
use itertools::Itertools;
use serde::Serialize;

/// The possible ways that parsing a part head specification can fail
pub type ParseError = InvalidRowError;

/// A struct that stores a specification for a set of part heads.  This contains the [`String`]
/// that the user entered into the part head box (which must be valid), as well as the
/// generated set of part heads.  The following invariants must be upheld:
/// - There is always at least one part head (0 part compositions can't exist)
/// - All the part_heads have the same [`Stage`]
#[derive(Debug, Clone, Eq, Serialize)]
pub struct PartHeads {
    /// The string that generated this set of [`PartHeads`].  This is allowed to change, provided
    /// that doing so would not change the value of `self.rows`
    spec: RefCell<String>,
    #[serde(serialize_with = "jigsaw_utils::serialisation::ser_rows")]
    rows: Vec<RowBuf>,
    /// A `HashSet` containing the same [`Row`]s as `rows`, used to make lookups more efficient.
    #[serde(skip)]
    set: HashSet<RowBuf>,
    /// `true` if [`Row`]s form a mathematical group.
    is_group: bool,
}

// The invariant of always having at least one part head means that `is_empty` would always
// return `false`
#[allow(clippy::len_without_is_empty)]
impl PartHeads {
    /// Creates a [`PartHeads`] struct containing only rounds (i.e. the [`PartHeads`] generated by
    /// the empty string).
    pub fn one_part(stage: Stage) -> Self {
        Self {
            rows: vec![RowBuf::rounds(stage)],
            set: {
                let mut set = HashSet::new();
                set.insert(RowBuf::rounds(stage));
                set
            },
            spec: RefCell::new(String::new()), // One-part comps are specified by the empty row
            is_group: true,                    // `{rounds}` is trivially a group
        }
    }

    /////////////
    // PARSING //
    /////////////

    /// Given a [`str`]ing specifying some part heads, attempts to parse and expand these PHs,
    /// or generate a [`ParseError`] explaining the problem.
    pub fn parse(s: &str, stage: Stage) -> Result<Self, ParseError> {
        let part_heads = Self::parse_and_expand(s, stage)?;
        Ok(Self::new(part_heads, s))
    }

    /// Attempts to parse `new_spec_string`, as though the user changed the contents of the 'part
    /// heads' box.  There are three cases (corresponding to the variants
    /// of `Result<ReparseOk, _>`:
    /// - `new_spec_string` can't be parsed, and `Err(`[`ParseError`]`)` is returned
    /// - `new_spec_string` is valid, and generates the same sequence of [`Row`]s as `self`.  In
    ///   this case, the specification string of `self` is updated (through interior mutability)
    ///   and `Ok(ReparseResult::SameRows)` is returned.
    /// - `new_spec_string` is valid, but generates a **different** sequence of [`Row`]s to `self`.
    ///   In this case, a `Ok(ReparseResult::DifferentRows(_))` is returned, containing a new set
    ///   of [`PartHeads`] which correspond to the new string.
    pub fn try_reparse(&self, new_spec_string: &str) -> Result<ReparseOk, ParseError> {
        if new_spec_string == *self.spec.borrow() {
            // If `new_spec_string` is identical to that of 'self', then the parsed rows must be
            // the same.  `try_reparse` is called every frame, and in the overwhelming majority of
            // frames the part head string won't change.  Therefore, for maximum frame rate it's
            // worth checking this before parsing.
            return Ok(ReparseOk::SameRows);
        }

        let parsed_part_heads = Self::parse_and_expand(new_spec_string, self.stage())?;
        if parsed_part_heads == self.rows {
            // If the rows are the same, then update the spec string in-place.  This won't generate
            // an undo step, even if the strings are different.
            self.spec.replace(new_spec_string.to_owned());
            Ok(ReparseOk::SameRows)
        } else {
            // If the new rows are different, then leave `self` unmodified and create a fresh
            // [`PartHeads`]
            let new_part_heads = Self::new(parsed_part_heads, new_spec_string);
            Ok(ReparseOk::DifferentRows(new_part_heads))
        }
    }

    /// Attempt to parse then expand a [`str`]ing as a comma-delimited sequence of [`Row`]s.  This
    /// returns an [`InvalidRowError`] if any of the [`Row`]s couldn't be parsed.
    ///
    /// Expansion converts a sequence of 'generator' rows to the full sequence of part heads, given
    /// the generators (e.g. `[1342]` will expand to `[1234, 1342, 1423]`, and `[13452, 15432]`
    /// will expand to `[12345, 15432, 13452, 12543, ...]`).
    fn parse_and_expand(s: &str, stage: Stage) -> Result<Vec<RowBuf>, InvalidRowError> {
        let generators = s
            .split(',')
            .map(|sub_str| RowBuf::parse_with_stage(sub_str, stage))
            .collect::<Result<Vec<_>, _>>()?;
        // Get the closure (i.e. every power of) each generator
        let closures = generators
            .iter()
            .map(|r| r.closure_from_rounds())
            .collect_vec();
        // Multiply every set of powers of `generators` to get the part heads
        let part_heads = Row::multi_cartesian_product(&closures).unwrap();
        Ok(part_heads)
    }

    fn new(part_heads: Vec<RowBuf>, s: &str) -> PartHeads {
        PartHeads {
            spec: RefCell::new(s.to_owned()),
            set: part_heads.iter().cloned().collect(),
            is_group: Row::is_group(part_heads.iter().map(RowBuf::as_row)).unwrap(),
            rows: part_heads,
        }
    }

    /////////////
    // GETTERS //
    /////////////

    /// Returns a new copy of the [`String`] that specifies this set of `PartHeads`
    #[inline]
    pub fn spec_string(&self) -> String {
        self.spec.borrow().clone()
    }

    /// The number of part heads in this set of `PartHeads`.
    #[inline]
    pub fn len(&self) -> usize {
        self.rows.len()
    }

    /// Returns a slice over the part heads in this set of `PartHeads`
    #[inline]
    pub fn rows(&self) -> &[RowBuf] {
        &self.rows
    }

    /// Returns a slice over the part heads in this set of `PartHeads`
    #[inline]
    pub fn stage(&self) -> Stage {
        self.rows[0].stage()
    }

    /// Given a pair of [`Row`], determines if they should be deemed 'equivalent' under these
    /// `PartHeads`.  I.e. this means that taking any [`Row`] and applying the transposition
    /// between `from` and `to` should produce the same [`Row`]s under part expansion as the
    /// original.
    pub fn are_equivalent(&self, from: &Row, to: &Row) -> Result<bool, IncompatibleStages> {
        // Calculate the transposition `from -> to`, and check that all the stages match
        let transposition = Row::solve_xa_equals_b(from, to)?;
        IncompatibleStages::test_err(self.stage(), transposition.stage())?;
        if self.is_group {
            // If the part heads form a group, then any pair of rows whos transposition is
            // contained in the group is considered equal
            Ok(self.set.contains(&transposition))
        } else {
            // PERF: Store this result in a `RefCell<HashMap<Row, bool>>`
            let mut transposed_row_buf = RowBuf::rounds(Stage::ONE);
            for r in &self.rows {
                // The unsafety here is OK because all the rows in `self` must have the same
                // stage, and we checked that `transposition` shares that Stage.
                unsafe { r.mul_into_unchecked(&transposition, &mut transposed_row_buf) };
                if !self.set.contains(&transposed_row_buf) {
                    // If any of the transposed rows aren't in the group, then we return false
                    return Ok(false);
                }
            }
            Ok(true)
        }
    }

    /// `true` if the `PartHeads` form a group.  This value is cached, so this function compiles
    /// down to a field access (i.e. it's really fast).
    pub fn is_group(&self) -> bool {
        self.is_group
    }
}

// Two PartHeads are equal if their specifications are the same; the `part_heads` vec is
// dependent on the spec so if the specs are equal, the `part_heads` must be too.
impl PartialEq for PartHeads {
    fn eq(&self, other: &PartHeads) -> bool {
        self.spec == other.spec
    }
}

/// The result of successfully [`reparsing`](PartHeads::try_reparse) a sequence of [`PartHeads`] - i.e.
/// modifying the 'part head' box in the GUI.
#[derive(Debug, Clone)]
pub enum ReparseOk {
    /// The new [`String`] generates the same sequence of [`PartHeads`], so the spec string of the
    /// [`PartHeads`] was modified in-place, using interior mutability
    SameRows,
    /// The new [`String`] parses to a valid sequence of [`PartHeads`] that's different to the
    /// current one.  Therefore, the existing [`PartHeads`] is left untouched and a new sequence of
    /// [`PartHeads`] is returned.
    DifferentRows(PartHeads),
}
